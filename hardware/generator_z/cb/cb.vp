//; use POSIX;
//; my $width  = parameter(Name=>'width', val=> 16, doc=>'Bus width for SB');
//; my $num_tracks = parameter(Name=>'num_tracks', val=> 10, doc=>'num_tracks Count for SB'); 
//; my $feedthrough_outputs = parameter(Name=>'feedthrough_outputs', val=> "1111101111", doc=>'binary vector for specifying tracks that are muxed. MSB corresponds to track 0 eg: 1011 means tracks 0, 2, 3 are muxed to produce output for PE. Length in bits = num_tracks.');
//; my $has_constant = parameter(Name=>'has_constant', val=> 1, doc=>'set to 1 if the CB has a register to supply a constant '); 

//; my @feedthrough = split('',$feedthrough_outputs);

module `mname` (
clk, reset,
//; for(my $i=0; $i<($num_tracks*2); $i++) {
//;  if ($feedthrough[($i%$num_tracks)]==1) {
in_`$i`,
//;   }
//; }
out,
config_addr,
config_data,
config_en
);

  input  clk;
  input  reset;
  input  config_en;
  input [31:0] config_data;

  // Bits [31:24] are for switch box, [23:0] for connection box.
  // So we have to let the linter know (verilator directives below) or it complains:
  // %Warning-UNUSED: .../cb_unq1.v:73: Bits of signal are not used: config_addr[23:0]
  // FIXME Owner please confirm that this is correct and delete this FIXME line (but keep the rest)
  // FIXME someday? Maybe shouldn't bring in all 32 bits if we're not going to use them?

  /* verilator lint_off UNUSED */
  input [31:0] config_addr;
  /* verilator lint_on UNUSED */

  output reg [`$width-1`:0] out;
//; for(my $i=0; $i<($num_tracks*2); $i++) {
//;   if ($feedthrough[$i%$num_tracks]==1) {
  input [`$width-1`:0] in_`$i`;
//;   }
//; }

//; # ############################################
//; # Setup register for CB mux configuration
//; # ############################################

//; my $feedthrough_count=$num_tracks;
//; for(my $i=0; $i< scalar @feedthrough; $i++) { $feedthrough_count -= $feedthrough[$i] }

//; my $mux_sel_bit_count = int(ceil(log(($num_tracks*2) - $feedthrough_count + $has_constant)/log(2)));
//; my $constant_bit_count = $has_constant * $width;
//; my $config_bit_count = $mux_sel_bit_count + $constant_bit_count;
//; my $config_reg_width = int(ceil($config_bit_count/32.0)*32);

  // Note not all config bits are used by this module.  Is this on purpose?
  // As a result, however, verilator needs lint directives or it complains:
  // %Warning-UNUSED: .../cb_unq1.v:91: Bits of signal are not used: config_cb[31:20]
  // %Warning-UNUSED: .../cb_unq2.v:91: Bits of signal are not used: config_cb[31:5]
  // [FIXME Owner please confirm that this is correct and delete this FIXME line]

  /* verilator lint_off UNUSED */
  reg [`$config_reg_width-1`:0] config_cb;
  /* verilator lint_on UNUSED */

  //; my $config_addrs_needed = int(ceil($config_bit_count / 32.0));
  always @(posedge clk) begin
    if (reset==1'b1) begin

      // Seems like the entire register should be initialized, not just a subset of the bits, yes?
      // FIXME Owner please check that this is still correct!
      // config_cb <= `$config_bit_count`'d0;
      config_cb <= `$config_reg_width`'d0;

    end else begin
      if (config_en==1'b1) begin
         case (config_addr[31:24])
  //; for (my $j=0; $j<$config_addrs_needed; $j=$j+1) {
           8'd`$j`: config_cb[`($j+1)*32-1`:`$j*32`] <= config_data;
  //; }

  //; # FIXME: 'for' loop ,above, generated this:
  //; # 
  //; #   case (config_addr[31:24])
  //; #     8''d0: config_cb[31:0] <= config_data;
  //; #   endcase
  //; # 
  //; # So naturally verilator complained:
  //; # %Warning-CASEINCOMPLETE: .../cb_unq1.v:109: Case values incompletely covered (example pattern 0x1)
  //; # So I''m adding a no-op default case (below)...but is this okay?
  //; # FIXME: Owner please verify this is okay and delete this comment block.
           default: ;

         endcase
      end
    end
  end

//; # ###############################################
//; # Setup input mux
//; # ###############################################
//;my $filename = "CB".$self->mname();
//;open(CBINFO, ">$filename") or die "Couldn't open file $filename, $!";
//;print CBINFO "        <sel_width>$mux_sel_bit_count</sel_width>\n";
//;#print CBINFO "        <has_constant>$has_constant</has_constant>\n";
//;print CBINFO "        <mux snk='out'>\n";
//; my $sel=0;
  always @(*) begin
    case (config_cb[`$mux_sel_bit_count - 1`:0])
//; for(my $i=0; $i<($num_tracks*2); $i++) {
//;   if ($feedthrough[$i%$num_tracks]==1) {

        // FIXME: Owner please verify that this lint fix won't break anything.
        // default: out <= `$width`'d0;
        // %Warning-COMBDLY: .../cb_unq1.v:134:
        // Delayed assignments (<=) in non-clocked (non flop or latch) block; suggest blocking assignments (=).

        // `$mux_sel_bit_count`'d`$sel`: out <= in_`$i`;
        `$mux_sel_bit_count`'d`$sel`: out = in_`$i`;
//;     print CBINFO "          <src sel='$sel'>in_$i</src>\n";
//;     $sel++;
//;   }
//; }
//;   if ($has_constant==1) {

        // FIXME: Owner please verify that this lint fix won't break anything.
        // default: out <= `$width`'d0;
        // %Warning-COMBDLY: .../cb_unq1.v:134:
        // Delayed assignments (<=) in non-clocked (non flop or latch) block; suggest blocking assignments (=).

        // default: out <= config_cb[`$mux_sel_bit_count+$constant_bit_count-1`:`$mux_sel_bit_count`];
        default: out = config_cb[`$mux_sel_bit_count+$constant_bit_count-1`:`$mux_sel_bit_count`];

//;     $sel++;
//;   } else {

        // FIXME: verify that this is the correct fix...
        // %Warning-COMBDLY: .../cb_unq1.v:134:
        // Delayed assignments (<=) in non-clocked (non flop or latch) block; suggest blocking assignments (=).

        // default: out <= `$width`'d0;
        default: out = `$width`'d0;

//;   }
    endcase
  end
endmodule
//;print CBINFO "        </mux>\n";
//;close CBINFO;

//;# generate corresponding testbench
//;# my $tb = generate_base('tb_cb', 'tb_cb', width => $width, num_tracks => $num_tracks, feedthrough_outputs => $feedthrough_outputs);

//;# generate corresponding place and route scripts
//;# my $pnr = generate_base('cb_pnr', 'cb_pnr');
