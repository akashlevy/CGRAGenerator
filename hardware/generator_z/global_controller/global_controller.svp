//; use POSIX;
//; my $jtag_obj = generate("jtag", "jtag_controller");
//; my $jtag_ifc_path = $self -> define_param(IFC => $jtag_obj -> get_param('IFC'));
//; my $jtag_ifc = clone($jtag_ifc_path, 'jtag_ifc');
//; my $cfg_bus_width = $jtag_obj -> get_param('SYSCLK_CFG_BUS_WIDTH');
//; my $cfg_addr_width = $jtag_obj -> get_param('SYSCLK_CFG_ADDR_WIDTH');
//; my $cfg_op_width = $jtag_obj -> get_param('SYSCLK_CFG_OPCODE_WIDTH');
//; my $addr_width = $cfg_addr_width + $cfg_op_width; #address and op concatenated in port
//; my $dummy_value = parameter(Name=>'dummy_value', val=> 0, doc=>'dummy value. placeholder.'); 

module `mname` (
clk_in, reset_in,
config_data_in,
config_addr_out,
config_data_out,
clk_out,
reset_out,
tdi,
tdo,
tms,
tck,
trst_n
);
  
  input  tck;
  input  clk_in;
  input  reset_in;
  input  tdi;
  input  tms;
  input  trst_n;
  input [`$cfg_bus_width-1`:0] config_data_in;

  output reg [`$addr_width-1`:0] config_addr_out;
  output reg [`$cfg_bus_width-1`:0] config_data_out;
  output reg clk_out;
  output reg reset_out;
  output tdo;

  wire [`$addr_width-1`:0] config_addr_jtag_out;
  wire [`$cfg_bus_width-1`:0] config_data_jtag_out;
  reg [`$cfg_bus_width-1`:0] config_data_jtag_in;
  wire [`$cfg_op_width-1`:0] op;
  reg clk;
  reg clk_domain;
  reg sys_clk_activated;
  //separate op out from address field
`$jtag_ifc -> instantiate` (.Clk(clk), .Reset(reset_in));
`$jtag_obj -> instantiate` (.ifc(`$jtag_ifc->iname()`),
			    .sys_clk_activated(sys_clk_activated),
			    .bsr_tdi(),
			    .bsr_sample(),
			    .bsr_intest(),
			    .bsr_extest(),
			    .bsr_update_en(),
			    .bsr_capture_en(),
		 	    .bsr_shift_dr(),
			    .bsr_tdo()
			    );

//Connect signals to jtag_ifc ports
      assign `$jtag_ifc->iname()`.tck=tck;
      assign `$jtag_ifc->iname()`.tdi=tdi;
      assign `$jtag_ifc->iname()`.tms=tms;
      assign `$jtag_ifc->iname()`.trst_n=trst_n;
      assign `$jtag_ifc->iname()`.config_data_from_gc=config_data_jtag_in; 
      assign tdo = `$jtag_ifc->iname()`.tdo;
      assign config_data_jtag_out = `$jtag_ifc->iname()`.config_data_to_gc;
      assign config_addr_jtag_out = `$jtag_ifc->iname()`.config_addr_to_gc;
 
  //OPCODES
  parameter NOP = `$cfg_op_width`'d0;
  parameter write_config =`$cfg_op_width`'d1;
  parameter read_config = `$cfg_op_width`'d2;
  //parameter set_base_reg = `$cfg_op_width`'d3;
  //parameter set_rw_and_count = `$cfg_op_width`'d4;
  //parameter burst_start = `$cfg_op_width`'d5;
  parameter read_data = 5'd6;
  parameter write_A050 = 5'd7;
  parameter write_TST = 5'd8;
  parameter read_TST = 5'd9;
  parameter global_reset = 5'd10;
  parameter reset_tile = 5'd11; 
  parameter stall = 5'd12;
  parameter advance_clk = 5'd13;
  parameter resume_clk = 5'd14;
  parameter sys_clk_on = 5'd15;
  parameter wr_rd_delay_reg = 5'd16;
  parameter rd_rd_delay_reg = 5'd17;

  //STATES FOR IGNORING INCOMING INSTRUCTIONS
  parameter ready = 2'd0;
  parameter reading = 2'd1;
  parameter resetting = 2'd2;
  parameter advancing_clk = 2'd3;

  reg [1:0] state;
 
  reg all_stalled_tck;
  reg all_stalled_sys;
  reg cgra_stalled;
  reg pulsing;
  reg clk_switch_request;
  reg [`$cfg_bus_width-1`:0] TST;
  reg [`$cfg_bus_width-1`:0] counter;
  reg [`$cfg_bus_width-1`:0] rd_delay_reg;
  reg [5:0] clk_switch_counter;
  assign op = config_addr_jtag_out[`$addr_width-1`:`$addr_width-$cfg_op_width`];
  always_comb begin
    	clk_domain = (sys_clk_activated) ? clk_in : tck;//Are we running the GC/CGRA on sys clk or test clk?
	clk = ((all_stalled_tck & !sys_clk_activated) | (all_stalled_sys & sys_clk_activated )) ? 0 : clk_domain; //Are we stalling both GC and CGRA during clk domain switch?
    	clk_out = (cgra_stalled & (state != advancing_clk)) ? 0 : clk; //Are we stalling CGRA and not GC?
   	reset_out = (state==resetting) ? 1 : reset_in;
  end
  reg [2:0] sync_counter;
  //Clock switch counter block (Always on test_clk)
  always @ (posedge tck or posedge reset_in) begin
	if (reset_in==1) begin
		clk_switch_counter <= `$cfg_bus_width`'d20;
		sys_clk_activated <= 0;//JUST TO MAKE TESTS PASS. THIS SHOULD BE 0
		all_stalled_tck <= 0;
	end
	else if ((clk_switch_counter > 0) & (clk_switch_request == 1)) begin
		all_stalled_tck <= 1;//Deactivate clk to rest of GC
		clk_switch_counter <= clk_switch_counter - 1;	
	end
	else if (!sys_clk_activated & clk_switch_counter <= 0 ) begin
		sys_clk_activated <= 1;
	end	
  end
  always @ (negedge clk_in or posedge reset_in) begin //NEGEDGE TO PREVENT SHORT CLK CYCLE (TIME BETWEEN RISING EDGES)
	if (reset_in==1) begin
		all_stalled_sys <= 1;
		sync_counter <= 3'd7;
	end
	else if (sys_clk_activated && sync_counter > 0)
		sync_counter <= sync_counter - 1;
	else if (sys_clk_activated && sync_counter <= 0)
		all_stalled_sys <= 0;
  end
  always @ (posedge clk or posedge reset_in) begin
    	if (reset_in==1) begin
		cgra_stalled <= 0;
		pulsing <= 0;
       		clk_switch_request <= 0;
		rd_delay_reg <= 16;
		TST <= 0;
		counter <= 0;
		config_addr_out <= 0;
		config_data_out <= 0;
		config_data_jtag_in <= 0;
    	end

    	else begin
    		if (state==ready) begin
    			case(op)
			NOP: begin
				config_addr_out <= {op,config_addr_out[`$cfg_addr_width-1`:0]};
				config_data_out <= config_data_out;
				config_data_jtag_in <= config_data_jtag_in;	
			end
			write_config: begin
				config_addr_out <= config_addr_jtag_out;
				config_data_out <= config_data_jtag_out; 
			end
			read_config: begin
				config_addr_out <= config_addr_jtag_out;
				config_data_out <= config_data_jtag_out; 
				counter <= rd_delay_reg-1;
				state <= reading;
			end
			read_data: begin
				config_addr_out <= config_addr_jtag_out;
				config_data_out <= config_data_jtag_out; 
				counter <= rd_delay_reg-1;
				state <= reading;
			end
			write_A050: begin
				config_data_jtag_in <= `$cfg_bus_width`'hA050;
			end
			write_TST: begin
				TST <= config_data_jtag_out;
			end
			read_TST: begin
				config_data_jtag_in <= TST;
			end
			global_reset: begin
				state <= resetting;
				counter <= (config_data_jtag_out > 0) ? config_data_jtag_out-1 : `$cfg_bus_width`'d19;
			end
			reset_tile: begin
				config_addr_out <= config_addr_jtag_out;
				config_data_out <= config_data_jtag_out; 
			end
			stall: begin
				cgra_stalled <= 1;
			end			
			advance_clk: begin
				if (cgra_stalled) begin
					counter <= config_data_jtag_out-1;
					state <= advancing_clk;	
				end
			end
			resume_clk: begin
				cgra_stalled <= 0;
			end
			sys_clk_on: begin
				clk_switch_request <= 1;
			end
			wr_rd_delay_reg: begin
				rd_delay_reg <= config_data_jtag_out;
			end
			rd_rd_delay_reg: begin
				config_data_jtag_in <= rd_delay_reg;
			end
			default: begin
				config_addr_out <= {NOP,config_addr_out[`$cfg_addr_width-1`:0]};
				config_data_out <= config_data_out;
				config_data_jtag_in <= config_data_jtag_in;	
			end
			endcase
		end
		//Counter for any state that needs to block incoming instructions
		else begin
			config_addr_out <= {NOP,config_addr_out[`$cfg_addr_width-1`:0]};
			if (counter > 0) begin
				counter <= counter-1;
			end
			else begin
				state <= ready;
				if (state == reading) 
					config_data_jtag_in <= config_data_in;
			end
		end    	
  	end
  end
	

endmodule
