/* *****************************************************************************
 * File: template.vp
 * Author: Ofer Shacham
 * 
 * Description:
 * This module is the top of the actual design.
 * 
 * REQUIRED GENESIS PARAMETERS:
 * ----------------------------
 * * IO_LIST -  List of main design IOs. For each IO you must specify:
 *   * name
 *   * width
 *   * direction - allowed directions are 'in'/'out'
 *   * bsr - put IO on boundary scan? (yes/no)
 *   * pad - pad type (analog or anl/digital or dig)
 *   * orientation - Orientation of the IO pad. allowed values are {left, right, 
 *		     top, bottom}
 * 
 * SYSCLK_CFG_BUS_WIDTH (48) -  Bus width for system clocked configuration entities
 * SYSCLK_CFG_ADDR_WIDTH (18) - Address width for system clocked configuration entities
 * TESTCLK_CFG_BUS_WIDTH (32) - Bus width for test clocked configuration entities
 * TESTCLK_CFG_ADDR_WIDTH (12) - Address width for test clocked configuration entities
 * 
 * 
 * Inputs:
 * -------
 * Main design inputs, plus  
 * inputs that regard the boundary scan and pads control
 * 
 * Outputs:
 * --------
 * Main design outputs, plus 
 * outputs that regard the boundary scan and pads control
 * 
 * Change bar:
 * -----------
 * Date          Author   Description
 * Mar 28, 2010  shacham  init version  --  
 * May 18, 2010  shacham  Added orientation feild to IO parameter list
 * May 24, 2010  shacham  Pulled config bus parameters to top level
 *			  Added cfg_ifc as the proper way to implement config
 *			  bus uniformity amongst modules.
 *			  Made declaration of IO params into a force_param to
 *			  make it immutable
 * ****************************************************************************/
// ACTUAL GENESIS2 PARAMETERIZATIONS

//; # Now, let's decide upon the parameters of the configuration bus:
//; my $tc_cfg_bus_width =  $self->define_param(TESTCLK_CFG_BUS_WIDTH => 16);
//; my $tc_cfg_addr_width =  $self->define_param(TESTCLK_CFG_ADDR_WIDTH => 30);
//; my $IDCODE = $self->define_param(IDCODE => 1);

   //  Config interfaces for system and test clock domains (DO I NEED SYS_CLK_IFC??)
 //; my $tc_jtag2gc_ifc = $self->unique_inst('cfg_ifc', 'tc_jtag2gc_ifc',
 //;					      DataWidth => $tc_cfg_bus_width, 
 //;					      AddrWidth => $tc_cfg_addr_width); 
 //; my $tc_gc2jtag_ifc = $self->clone_inst($tc_jtag2gc_ifc, 'tc_gc2jtag_ifc'); 
`$tc_jtag2gc_ifc->get_module_name()` `$tc_jtag2gc_ifc->get_instance_name()`();
`$tc_gc2jtag_ifc->get_module_name()` `$tc_gc2jtag_ifc->get_instance_name()`();


module `$self->get_module_name()`
  (
   // main IOs
   //Address and Data going out to the global controller
   `$tc_jtag2gc_ifc->get_instance_name()`.cfgOut cfgOut,
   //Data coming back from the global controller
   `$tc_gc2jtag_ifc->get_instance_name()`.cfgIn cfgIn,
   input tck,
   input trst_n,
   input tdi,
   input tms,
   //input [`#$tc_cfg_addr_width-1`:0] config_addr_from_gc,
   //input [`#$tc_cfg_bus_width-1`:0] config_data_from_gc, 
   output tdo,
   output clk_to_gc,
   output reset_to_gc,
   //output [`#$tc_cfg_addr_width-1`:0] config_addr_to_gc,
   //output [`#$tc_cfg_bus_width-1`:0] config_data_to_gc, 
   // Signals for the Boundary Scan Register (these are not chip IOs though)
    output 				bsr_tdi,
    output 				bsr_sample,
    output 				bsr_intest,
    output 				bsr_extest,
    output 				bsr_update_en,
    output 				bsr_capture_en,
    output 				bsr_shift_dr,
    input 				bsr_tdo
   );


   // Reset to the test clock domain (this is different than the trst signal)
   logic 				test_logic_reset;
   // Connect Forward the reset and clock inputs to the global controller
   assign reset_to_gc = trst_n;
   assign clk_to_gc = tck;


   //;
   //;
   //;
   //; # Create the JTAG to reg-files controller object
   //; my $cfg_dbg = $self->unique_inst('cfg_and_dbg', 'cfg_and_dbg',
   //;					SC_CFG_BUS => 'no', #SC_CFG_IFC_REF => $sc_jtag2rf_ifc, 
   //;					TC_CFG_BUS => 'yes', TC_CFG_IFC_REF => $tc_jtag2gc_ifc, 
   //;					);
   //;
			
   // Instantiate the JTAG to reg-files controller
   `$cfg_dbg->get_module_name()` `$cfg_dbg->get_instance_name()`
     (
      // JTAG signals
      .tms(tms),
      .tck(tck),
      .trst_n(trst_n),
      .tdi(tdi),
      .tdo(tdo),
      .tdo_en(tdo_en),
      
      // BSR interface //Do I need this? Don't think so
      .bsr_extest(bsr_extest),
      .bsr_intest(bsr_intest),
      .bsr_sample(bsr_sample),
      .bsr_capture_en(bsr_capture_en),
      .bsr_shift_dr(bsr_shift_dr),
      .bsr_update_en(bsr_update_en),
      .bsr_tdo(bsr_tdo),
      
      
      // signals to the jtag clocked global controller
      .tc_cfgReq(cfgOut),
      .tc_cfgRep(cfgIn),
      .test_logic_reset(test_logic_reset)
      );

   
endmodule // `$self->get_module_name()`
