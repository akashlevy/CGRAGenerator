////////////////////////////////////////////////////////////////////////////////
//
// Test bench for PE compute.
//
////////////////////////////////////////////////////////////////////////////////
//;
//; my $dut         = generate('test_pe', 'dut');

module  `mname()`;

localparam DataWidth = 16;

logic                   clk;
logic                   clk_en;
logic                   rst_n;

logic [2*DataWidth-1:0]       cfg_d;
logic [7:0]             cfg_a;
logic                   cfg_en;
logic [DataWidth-1:0]       data0;
logic [DataWidth-1:0]       data1;
logic [DataWidth-1:0]       data2;
logic                   bit0;
logic                   bit1;
logic                   bit2;
logic [DataWidth-1:0]       res;
logic                   res_p;
logic [DataWidth-1:0]       read_data;
logic [DataWidth-1:0]       temp_data;

logic [2*DataWidth-1:0]       cfg_d_w;
logic [7:0]             cfg_a_w;
logic                   cfg_en_w;
logic [DataWidth-1:0]       data0_w;
logic [DataWidth-1:0]       data1_w;
logic [DataWidth-1:0]       data2_w;
logic                   bit0_w;
logic                   bit1_w;
logic                   bit2_w;
bit [DataWidth-1:0]     exp_res;
bit                      exp_res_p;
bit                     ignore_res;
bit                     ignore_res_p;

bit fail, fail_latch;

always_ff @(posedge clk or negedge rst_n) begin
    if(~rst_n)
        fail_latch <= 0;
    else if(fail)
        fail_latch <= 1;
end

assign fail_res     = ~ignore_res & (exp_res !== res);
assign fail_res_p = ~ignore_res_p & (exp_res_p !== res_p);

initial begin
    #1000000 $display("Time = %d clk = %b", $time, clk);

    if(fail_latch)
        $display("\nAt least one test has FAILED!\n");
    else
        $display("\nAll tests Passed\n");

     $finish;
end

initial begin
    clk = 0;
    forever begin
    #5 clk = ~clk;
    end
end

initial begin
    rst_n = 0;
    repeat(10) @(posedge clk);
    rst_n = 1;
end


/********************************************
Commands to PE
********************************************/

typedef enum {
    RegA_load, RegB_load, RegC_load, RegD_load, RegE_load, RegF_load,
    RegA_bypass, RegA_valid, RegA_const, RegB_bypass, RegB_valid, RegB_const, Regfile_mode,
    Regfile0_load, Regfile1_load, Regfile2_load, Regfile3_load,
    Regfile0_read, Regfile1_read, Regfile2_read, Regfile3_read
} command;

command next_cmd;
command current_cmd;

/********************************************
Opcodes in PE
********************************************/

typedef enum {
    Add_op, Sub_op, Abs_op, GteMax_op, LteMin_op, Eq_op,
    Sel_op, Rshft_op, RshftS_op, Lshft_op, Mult0_op, Mult1_op, Mult2_op, Or_op,
    And_op, Xor_op, Inv_op, Cntr_op, Div_op, Acc_op, InvalidOp
} oper;

oper next_op;
oper current_op;


/********************************************
Flipflop for opcode
********************************************/
always_ff @(posedge clk) begin
    if (~rst_n) begin
        next_op <= Add_op;
        current_op <= Add_op;
        is_signed_pre_next <= 1'b0;
    end
    else begin
        next_op <= pe_oper'($urandom_range(18,0));
        current_op <= next_op; 
        is_signed_pre_next <= $urandom_range(1,0);
    end
end

/********************************************
Flipflop for command 
********************************************/
always_ff @(posedge clk) begin
    if (~rst_n) begin
        next_op <= Add_op;
        current_op <= Add_op;
        is_signed_pre_next <= 1'b0;
    end
    else begin
        next_op <= pe_oper'($urandom_range(18,0));
        current_op <= next_op; 
        is_signed_pre_next <= $urandom_range(1,0);
    end
end

/********************************************
Test for loading registers
********************************************/

always_comb begin
    cfg_d_w = 'h0;
    cfg_a_w = 'h0;
    cfg_en_w = 'h0;
    data0_w = 'h0;
    data1_w = 'h0;
    data2_w = 'h0;
    bit0_w = 'h0;
    bit1_w = 'h0;
    bit2_w = 'h0;
    case(next_cmd)
        RegA_load : begin
            cfg_a_w = 8'hF0;
            temp_data = $urandom_range(2**DataWidth - 1,0);
            cfg_d_w = temp_data;
            cfg_en_w = 1;
        end
        RegB_load : begin
            cfg_a_w = 8'hF1;
            temp_data = $urandom_range(2**DataWidth - 1,0);
            cfg_d_w = temp_data;
            cfg_en_w = 1;
        end
//---------------------------------------------------------
//TODO add remaining register load modes
//---------------------------------------------------------

        RegA_const : begin
            cfg_a_w = 8'hFF;
            cfg_d_w[17:16] = 2'h0; 
            cfg_en_w = 1;
        end
        RegB_const : begin
            cfg_a_w = 8'hFF;
            cfg_d_w[20:18] = 3'h0;
            cfg_en_w = 1;
        end
        Regfile_mode : begin
            cfg_a_w = 8'hFF;
            cfg_d_w[20:18] = 3'h4;
            cfg_en_w = 1;
        end

        Regfile0_load : begin
            cfg_a_w = 8'hF1;
            temp_data = $urandom_range(2**DataWidth - 1,0);
            cfg_d_w[15:0] = temp_data;
            cfg_en_w = 1;
        end
        Regfile1_load : begin
            cfg_a_w = 8'hE0;
            temp_data = $urandom_range(2**DataWidth - 1,0);
            cfg_d_w[15:0] = temp_data;
            cfg_en_w = 1;
        end
        Regfile2_load : begin
            cfg_a_w = 8'hE1;
            temp_data = $urandom_range(2**DataWidth - 1,0);
            cfg_d_w[15:0] = temp_data;
            cfg_en_w = 1;
        end
        Regfile3_load : begin
            cfg_a_w = 8'hE2;
            temp_data = $urandom_range(2**DataWidth - 1,0);
            cfg_d_w[15:0] = temp_data;
            cfg_en_w = 1;
        end
        Regfile0_read : begin
            data1_w = 16'h0;
        end
        Regfile1_read : begin
            data1_w = 16'h1;
        end
        Regfile2_read : begin
            data1_w = 16'h2;
        end
        Regfile3_read : begin
            data1_w = 16'h3;
        end
        default : begin
            cfg_d_w = 'h0;
            cfg_a_w = 'h0;
            cfg_en_w = 'h0;
            data0_w = 'h0;
            data1_w = 'h0;
            data2_w = 'h0;
            bit0_w = 'h0;
            bit1_w = 'h0;
            bit2_w = 'h0;
        end
    endcase
end


always_ff @(posedge clk or negedge rst_n) begin
    if (~rst_n) begin
        cfg_d <= 'h0;
        cfg_a <= 'h0;
        cfg_en <= 'h0;
        data0 <= 'h0;
        data1 <= 'h0;
        data2 <= 'h0;
        bit0 <= 'h0;
        bit1 <= 'h0;
        bit2 <= 'h0;
    end
    else begin
        cfg_d <= cfg_d_w;
        cfg_a <= cfg_a_w;
        cfg_en <= cfg_en_w;
        data0 <= data0_w;
        data1 <= data1_w;
        data2 <= data2_w;
        bit0 <= bit0_w;
        bit1 <= bit1_w;
        bit2 <= bit2_w;
    end
end

`$dut->instantiate()` (
    .clk (clk),
    .rst_n (rst_n),
    .clk_en (clk_en),
    .cfg_d (cfg_d),
    .cfg_a (cfg_a),
    .cfg_en (cfg_en),
    .data0 (data0),
    .data1 (data1),
    .data2 (data2),
    .bit0 (bit0),
    .bit1 (bit1),
    .bit2 (bit2),

    .res     (res),
    .irq (),
    .res_p (res_p),
    .read_data (read_data)
);


endmodule


