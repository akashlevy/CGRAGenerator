//; # Experimenting with globals
//; our @CGRA_INFO;

// New Top level that contains CGRA_core module and IO pad_ring module
//; #TOP LEVEL PARAMS
//; my $num_ios_per_side = parameter(name=>'num_ios_per_side', val=>16, min=>16, step=>16);
//; #Other values
//; my $num_ios_per_group = 16;
//; my $num_groups_per_side = $num_ios_per_side/$num_ios_per_group;
//; my @sides = ('N','S','E','W');
//; my $connect_GC = parameter(name=>'connect_GC', val=>0, min=>0, max=>1, step=>1);
//; my $config_addr_width = parameter(name=>'config_addr_width', val=>32, min=>1, step=>1);
//; my $config_data_width = parameter(name=>'config_data_width', val=>32, min=>1, step=>1);
//; my $num_stall_domains = parameter(name=>'num_stall_domains', val=>4, min=>1, step=>1);
module `mname` (
  //pads_{side}_{group_num_within_side} [bit number within group]
//; for (my $i=0; $i<$num_groups_per_side; $i++) {
  inout [`$num_ios_per_group-1`:0] pads_N_`$i`,
  inout [`$num_ios_per_group-1`:0] pads_S_`$i`,
  inout [`$num_ios_per_group-1`:0] pads_E_`$i`,
  inout [`$num_ios_per_group-1`:0] pads_W_`$i`,
//; }
//; if ($connect_GC == 0) {
  input [`$config_data_width-1`:0] config_data,
  input [`$config_addr_width-1`:0] config_addr,
//; }
  input tck,
  input tms,
  input trst_n,
  input tdi,
  output tdo,
  input clk_in,
  input reset_in
);


//; if ($connect_GC == 1) {
wire [`$config_data_width-1`:0] config_data;
wire [`$config_addr_width-1`:0] config_addr;
//; }
wire clk;
wire reset;
wire config_read;
wire config_write;
wire [`$config_data_width-1`:0] read_data;
wire [`$config_data_width-1`:0] read_data_core;
wire [`$config_data_width-1`:0] read_data_pads;
wire [`$num_stall_domains-1`:0] stall;

assign read_data = read_data_core | read_data_pads;

//; my $global_controller_obj = generate("global_controller", "global_controller");
    `$global_controller_obj->instantiate()`
    (
      .clk_in(clk_in),
      .reset_in(reset_in),
//; if($connect_GC == 1) {
      .clk_out(clk),
      .reset_out(reset),
      .config_addr_out(config_addr),
      .config_data_out(config_data),
      .write(config_write),
//; }
      .config_data_in(read_data),
      .tdi(tdi),
      .tdo(tdo),
      .tms(tms),
      .tck(tck),
      .trst_n(trst_n),
      .cgra_stalled(stall),
      .read(config_read)
    );


//; if($connect_GC == 0) {
assign clk = clk_in;
assign reset = reset_in;
assign config_write = 1;
//; }
//; my $jtag_ifc_path = parameter(NAME => 'IFC', VAL => $global_controller_obj -> get_param('IFC'), DOC => "Path to JTAG interface for JTAGDriver");

//; for (my $i=0; $i < $num_groups_per_side; $i++) {
//;   for my $side (@sides) {
  wire [`$num_ios_per_group-1`:0] f2p_wide_`$side`_`$i`;
  wire [`$num_ios_per_group-1`:0] f2p_1bit_`$side`_`$i`;
  wire [`$num_ios_per_group-1`:0] p2f_`$side`_`$i`;
//;   }
//; }


//; my $cgra_core_obj = generate_base("cgra_core","core");

  `$cgra_core_obj->instantiate()` (
//; for (my $i=0; $i < $num_groups_per_side; $i++) {
//;   for my $side (@sides) {
    .f2p_wide_`$side`_`$i`(f2p_wide_`$side`_`$i`),
    .f2p_1bit_`$side`_`$i`(f2p_1bit_`$side`_`$i`),
    .p2f_`$side`_`$i`(p2f_`$side`_`$i`),
//;   }
//; }
    .clk(clk),
    .reset(reset),
    .config_addr(config_addr),
    .config_data(config_data),
    .config_read(config_read),
    .config_write(config_write),
    .stall(stall),
    .read_data(read_data_core)
  );

//; my $pad_ring_obj = generate_base("pad_ring", "pads");

  `$pad_ring_obj->instantiate()` (

//; for (my $i=0; $i < $num_groups_per_side; $i++) {
//;   for my $side (@sides) {
    .f2p_wide_`$side`_`$i`(f2p_wide_`$side`_`$i`),
    .f2p_1bit_`$side`_`$i`(f2p_1bit_`$side`_`$i`),
    .pads_`$side`_`$i`(pads_`$side`_`$i`),
    .p2f_`$side`_`$i`(p2f_`$side`_`$i`),

//;   }
//; }
    .config_data(config_data),
    .config_addr(config_addr),
    .config_read(config_read),
    .config_write(config_write),
    .read_data(read_data_pads),
    .clk(clk),
    .reset(reset)
  );

//;open(INFO, ">>cgra_info.txt") or die "Couldn't open file cgra_info.txt, $!";
//; for my $side (1,2,3,4) {
//;    my $fname = "TILEio_group_unq$side";
    // $fname
//;    open(INP, "<$fname") or die "Couldn't open file $fname, $!";
//;    while (<INP>) { print INFO $_; }
//;    close INP;
//; }
//; print INFO "</CGRA>\n";
//; close INFO;




//;# //; open(INFO2, ">tmp.txt") or die "Couldn't open file tmp.txt, $!";
//;# //; print INFO2 "<CGRA>\n";
//;# //; for my $i (0 .. $#top::CGRA_INFO) {
//;# //;     # print INFO2 "----\n" . @top::CGRA_INFO[$i] . "\n";
//;# //;     print INFO2 @top::CGRA_INFO[$i];
//;# //;     # FIXME/TODO if no info, emit an empty tile
//;# //; }
//;# //; print INFO2 "</CGRA>\n";
//;# //; close INFO2;



//; open(INFO2, ">tmp.txt") or die "Couldn't open file tmp.txt, $!";
//; print INFO2 "<CGRA>\n";

//; # First sixteen tiles are IO
//; for my $i (0 .. 15) {
//;     print INFO2 @top::CGRA_INFO[$i];
//; }
//; my ($n_begin,$e_begin,$s_begin,$w_begin) = (0,16,32,48);
//; # Then sixteen rows of main grid bounded by IO
//; for my $a (0 .. 15) {
//;    my $i;
//;    for my $b (0..17) {
//;       if ($b == 0) { $i = $a + $w_begin; }           # west side pads
//;       elsif ($b == 17) { $i = $a + $e_begin; }       # east side pads
//;       else { $i = (4*16) + (16*$a) + ($b-1); } # pe/mem tiles
//;       print INFO2 @top::CGRA_INFO[$i];
//;    }
//; }
//; # Final sixteen tiles are IO (south side pads)
//; for my $i ($s_begin .. ($s_begin+15)) {
//;     print INFO2 @top::CGRA_INFO[$i];
//; }
//; # Remaining tiles (gst)
//; for my $i ((4*16+16*16) .. $#top::CGRA_INFO) {
//;     print INFO2 @top::CGRA_INFO[$i];
//; }

//; print INFO2 "</CGRA>\n";
//; close INFO2;




endmodule
