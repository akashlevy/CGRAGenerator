//; my $lut_inps = parameter(Name=>'lut_inps',
//;                               Val=>2, Min=>2, Step=>1, Max=>16,
//;                               Doc=>"Number of inputs to a LUT");
//;
//;my $c_in_decl = $lut_inps > 3 ? "["+($lut_inps-1)+":0]" : "     ";
//;
module  `mname`  #(
  parameter DataWidth = 16
) (
  input                  cfg_clk,
  input                  cfg_rst_n,
  input           [15:0] cfg_d,
  input           [7:0]  cfg_a,
  input                  cfg_en,

  // input  [DataWidth-1:0] op_a_in,
  // input  [DataWidth-1:0] op_b_in,
  input  [0] op_a_in,
  input  [0] op_b_in,

//; if ($lut_inps > 2) {
  input  `$c_in_decl`        op_c_in,
//;}

  // output logic [DataWidth-1:0] res
  output logic [0] res
);

// genvar ggg;
// generate
//  for (ggg = 0; ggg < DataWidth; ggg = ggg +1) begin : GEN_LUT

 // logic [`$lut_inps-1`:0] lut;
    logic [15:0] lut;

    always_ff @(posedge cfg_clk or negedge cfg_rst_n) begin
      if(~cfg_rst_n) begin
        lut   <= 15'h0;
      // end else if(cfg_en && (cfg_a == (0/4))) begin
      end else if(cfg_en && (cfg_a == 8'h0)) begin
        lut   <= cfg_d;
      end
    end

    assign res[0] = lut[{op_a_in[0], op_b_in[0]}];
  end
// endgenerate



endmodule




